
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sat Dec 10 19:29:21 CET 2016
//----------------------------------------------------

package javapack;

import java_cup.runtime.*;
import java.util.*;
import java.io.*;
import java.nio.file.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sat Dec 10 19:29:21 CET 2016
  */
public class Parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\072\000\002\002\004\000\002\023\003\000\002\002" +
    "\007\000\002\004\003\000\002\005\004\000\002\005\002" +
    "\000\002\006\007\000\002\006\003\000\002\007\004\000" +
    "\002\007\003\000\002\011\005\000\002\011\002\000\002" +
    "\011\003\000\002\003\005\000\002\010\003\000\002\010" +
    "\003\000\002\010\003\000\002\013\003\000\002\012\004" +
    "\000\002\012\002\000\002\014\004\000\002\014\005\000" +
    "\002\014\005\000\002\014\003\000\002\014\011\000\002" +
    "\014\006\000\002\014\003\000\002\021\012\000\002\022" +
    "\004\000\002\022\002\000\002\016\004\000\002\020\005" +
    "\000\002\020\002\000\002\017\003\000\002\017\003\000" +
    "\002\026\005\000\002\026\003\000\002\026\006\000\002" +
    "\026\003\000\002\027\005\000\002\027\005\000\002\027" +
    "\003\000\002\027\003\000\002\027\005\000\002\015\003" +
    "\000\002\015\003\000\002\015\004\000\002\015\006\000" +
    "\002\015\005\000\002\030\005\000\002\030\002\000\002" +
    "\030\003\000\002\025\003\000\002\025\003\000\002\025" +
    "\003\000\002\025\003\000\002\024\003\000\002\024\003" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\156\000\004\022\004\001\002\000\004\043\010\001" +
    "\002\000\004\002\007\001\002\000\004\002\000\001\002" +
    "\000\004\002\001\001\002\000\004\023\011\001\002\000" +
    "\010\003\013\011\014\024\ufffc\001\002\000\010\003\013" +
    "\011\014\024\ufffc\001\002\000\010\003\ufffa\011\ufffa\024" +
    "\ufffa\001\002\000\006\003\142\043\144\001\002\000\004" +
    "\024\020\001\002\000\004\024\ufffe\001\002\000\004\002" +
    "\uffff\001\002\000\022\003\027\025\uffee\026\026\030\022" +
    "\031\023\032\030\034\031\043\024\001\002\000\024\003" +
    "\uffea\025\uffea\026\uffea\030\uffea\031\uffea\032\uffea\034\uffea" +
    "\035\uffea\043\uffea\001\002\000\004\043\140\001\002\000" +
    "\004\016\137\001\002\000\004\004\107\001\002\000\024" +
    "\003\027\025\uffee\026\026\030\022\031\023\032\030\034" +
    "\031\035\uffee\043\024\001\002\000\004\043\104\001\002" +
    "\000\024\003\uffe7\025\uffe7\026\uffe7\030\uffe7\031\uffe7\032" +
    "\uffe7\034\uffe7\035\uffe7\043\uffe7\001\002\000\016\003\042" +
    "\012\044\013\036\040\043\042\040\043\041\001\002\000" +
    "\016\003\042\012\044\013\036\040\043\042\040\043\041" +
    "\001\002\000\006\025\ufff0\035\ufff0\001\002\000\004\025" +
    "\034\001\002\000\004\002\ufff4\001\002\000\014\014\uffdd" +
    "\021\uffdd\033\uffdd\036\uffdd\037\uffdd\001\002\000\016\003" +
    "\042\012\044\013\036\040\043\042\040\043\041\001\002" +
    "\000\004\021\064\001\002\000\004\044\062\001\002\000" +
    "\016\014\uffd8\021\uffd8\033\uffd8\036\uffd8\037\uffd8\044\057" +
    "\001\002\000\014\014\uffdb\021\uffdb\033\uffdb\036\uffdb\037" +
    "\uffdb\001\002\000\004\013\054\001\002\000\014\014\uffd7" +
    "\021\uffd7\033\uffd7\036\uffd7\037\uffd7\001\002\000\014\014" +
    "\uffe1\021\uffe1\033\uffe1\036\050\037\047\001\002\000\016" +
    "\003\042\012\044\013\036\040\043\042\040\043\041\001" +
    "\002\000\016\003\uffdf\012\uffdf\013\uffdf\040\uffdf\042\uffdf" +
    "\043\uffdf\001\002\000\016\003\uffe0\012\uffe0\013\uffe0\040" +
    "\uffe0\042\uffe0\043\uffe0\001\002\000\010\014\uffe3\021\uffe3" +
    "\033\uffe3\001\002\000\014\014\uffe1\021\uffe1\033\uffe1\036" +
    "\050\037\047\001\002\000\010\014\uffe2\021\uffe2\033\uffe2" +
    "\001\002\000\016\003\042\012\044\013\036\040\043\042" +
    "\040\043\041\001\002\000\004\014\056\001\002\000\014" +
    "\014\uffdc\021\uffdc\033\uffdc\036\uffdc\037\uffdc\001\002\000" +
    "\006\042\060\043\061\001\002\000\014\014\uffda\021\uffda" +
    "\033\uffda\036\uffda\037\uffda\001\002\000\014\014\uffd6\021" +
    "\uffd6\033\uffd6\036\uffd6\037\uffd6\001\002\000\004\043\063" +
    "\001\002\000\014\014\uffd9\021\uffd9\033\uffd9\036\uffd9\037" +
    "\uffd9\001\002\000\024\003\027\025\uffee\026\026\030\022" +
    "\031\023\032\030\034\031\035\uffee\043\024\001\002\000" +
    "\006\025\uffe4\035\067\001\002\000\004\025\071\001\002" +
    "\000\022\003\027\025\uffee\026\026\030\022\031\023\032" +
    "\030\034\031\043\024\001\002\000\004\025\uffe5\001\002" +
    "\000\004\034\072\001\002\000\004\016\073\001\002\000" +
    "\024\003\uffe6\025\uffe6\026\uffe6\030\uffe6\031\uffe6\032\uffe6" +
    "\034\uffe6\035\uffe6\043\uffe6\001\002\000\004\014\075\001" +
    "\002\000\014\014\uffde\021\uffde\033\uffde\036\uffde\037\uffde" +
    "\001\002\000\004\033\077\001\002\000\022\003\027\025" +
    "\uffee\026\026\030\022\031\023\032\030\034\031\043\024" +
    "\001\002\000\004\025\101\001\002\000\004\032\102\001" +
    "\002\000\004\016\103\001\002\000\024\003\uffe9\025\uffe9" +
    "\026\uffe9\030\uffe9\031\uffe9\032\uffe9\034\uffe9\035\uffe9\043" +
    "\uffe9\001\002\000\004\016\105\001\002\000\024\003\uffec" +
    "\025\uffec\026\uffec\030\uffec\031\uffec\032\uffec\034\uffec\035" +
    "\uffec\043\uffec\001\002\000\006\025\uffef\035\uffef\001\002" +
    "\000\016\012\110\013\116\020\113\040\114\042\117\043" +
    "\115\001\002\000\004\016\uffd5\001\002\000\016\003\131" +
    "\005\130\006\127\007\134\010\126\016\uffcf\001\002\000" +
    "\004\016\125\001\002\000\004\016\uffd4\001\002\000\004" +
    "\013\122\001\002\000\016\003\uffc9\005\uffc9\006\uffc9\007" +
    "\uffc9\010\uffc9\016\uffc9\001\002\000\016\003\042\012\044" +
    "\013\036\040\043\042\040\043\041\001\002\000\016\003" +
    "\uffc8\005\uffc8\006\uffc8\007\uffc8\010\uffc8\016\uffc8\001\002" +
    "\000\004\014\121\001\002\000\004\016\uffd1\001\002\000" +
    "\016\003\042\012\044\013\036\040\043\042\040\043\041" +
    "\001\002\000\004\014\124\001\002\000\004\016\uffd2\001" +
    "\002\000\024\003\uffe8\025\uffe8\026\uffe8\030\uffe8\031\uffe8" +
    "\032\uffe8\034\uffe8\035\uffe8\043\uffe8\001\002\000\006\042" +
    "\uffca\043\uffca\001\002\000\006\042\uffcc\043\uffcc\001\002" +
    "\000\006\042\uffcd\043\uffcd\001\002\000\004\016\uffce\001" +
    "\002\000\004\016\uffd3\001\002\000\006\042\117\043\115" +
    "\001\002\000\006\042\uffcb\043\uffcb\001\002\000\016\003" +
    "\131\005\130\006\127\007\134\010\126\016\uffcf\001\002" +
    "\000\004\016\uffd0\001\002\000\024\003\uffed\025\uffed\026" +
    "\uffed\030\uffed\031\uffed\032\uffed\034\uffed\035\uffed\043\uffed" +
    "\001\002\000\004\016\141\001\002\000\024\003\uffeb\025" +
    "\uffeb\026\uffeb\030\uffeb\031\uffeb\032\uffeb\034\uffeb\035\uffeb" +
    "\043\uffeb\001\002\000\004\017\ufff8\001\002\000\004\017" +
    "\152\001\002\000\010\003\146\015\147\017\ufff6\001\002" +
    "\000\004\017\ufff9\001\002\000\004\017\ufff5\001\002\000" +
    "\004\043\150\001\002\000\010\003\146\015\147\017\ufff6" +
    "\001\002\000\004\017\ufff7\001\002\000\010\003\154\027" +
    "\153\041\156\001\002\000\004\016\ufff3\001\002\000\004" +
    "\016\ufff1\001\002\000\004\016\157\001\002\000\004\016" +
    "\ufff2\001\002\000\010\003\ufffb\011\ufffb\024\ufffb\001\002" +
    "\000\004\024\ufffd\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\156\000\006\002\005\023\004\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\004\014\005\015\006\011\001" +
    "\001\000\006\005\157\006\011\001\001\000\002\001\001" +
    "\000\004\007\142\001\001\000\004\003\016\001\001\000" +
    "\002\001\001\000\002\001\001\000\012\012\031\013\032" +
    "\014\024\021\020\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\010\012\105" +
    "\014\024\021\020\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\016\075\026\044\027\034\001\001\000\010" +
    "\016\036\026\044\027\034\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\016\073\026\044\027\034\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\017\045\020\050\001" +
    "\001\000\006\026\051\027\034\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\017\045\020" +
    "\052\001\001\000\002\001\001\000\010\016\054\026\044" +
    "\027\034\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\012\031\013\064\014" +
    "\024\021\020\001\001\000\004\022\065\001\001\000\002" +
    "\001\001\000\012\012\031\013\067\014\024\021\020\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\012\012\031\013\077\014\024\021\020" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\015\111\024\110\001\001\000" +
    "\002\001\001\000\006\025\132\030\131\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\010\016\117\026\044\027\034\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\016" +
    "\122\026\044\027\034\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\024\134\001\001\000\002\001\001\000\006\025" +
    "\132\030\135\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\011\144\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\011\150\001" +
    "\001\000\002\001\001\000\004\010\154\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	public TablaSimbolos ts = new TablaSimbolos();
	public Arbol arbol = new Arbol();
	private String path;
	ArrayList<String> errores = new ArrayList<String>();

	public void report_error(String message, Object info) {
		String fallo = message;
		if (info instanceof Symbol)
			if (((Symbol)info).left != -1)
				fallo += " en el caracter " +
					((Symbol)info).left + " del archivo.";
		newError(message);
	}
	
	public void newError(String m){
		int c = errores.size();
		c++;
		errores.add("--> ERROR #"+c+" - "+m);
	}
	
	public void mostrarErrores(){
		System.out.println(
		"-------------------------------------------------------------------------------------------------------------------------------------------------"+
		"\nA continuacion se muestra la lista de errores encontrados:\n");
	
		for(String s : errores){
			System.out.println(s);
		}
		
		System.out.println(
		"-------------------------------------------------------------------------------------------------------------------------------------------------\n"+
		"*************************************************************************************************************************************************\n"+
		"****************************************\tSe ha(n) encontrado un total de "+errores.size()+" errores.\t*************************************************\n"+
		"*************************************************************************************************************************************************");
	}
	
	public Parser (java.io.Reader input) {
    	super(new Scan(input));
  	}
  	
  	public void limpiar(){
  		ts = new TablaSimbolos();
		path = null;
		errores = new ArrayList<String>();
		producciones = new ArrayList<String>();
		System.out.print("\n\n");
  	}
  	
  	public void ponerPath(String path){
  		this.path = path;
  	}
	
	public void syntax_error(Symbol s) {
		if(s.left > 0 && s.right > 0)
	  		report_error("(SINTaCTICO) Error de sintaxis linea " + s.left + ", columna " + s.right+"\n"+fallo(s.left,s.right), null);
	}
	
	public void report_fatal_error(String message, Object info) {
	  done_parsing();
	  report_error("(SINTaCTICO) Error de sintaxis fatal : "
	  + "No se puede recuperar del error y continuar con el analisis - "
	  + message + " ",(Symbol)info);
	  report_error("(SINTaCTICO) ** Final del analisis **", info);
	  mostrarErrores();
	  //System.exit(1);
	}
	
	public ArrayList<String> producciones = new ArrayList<String>();

	
	
	public void imprimirProducciones(){
		System.out.println(
		"-------------------------------------------------------------------------------------------------------------------------------------------------");
		System.out.println("Orden de las producciones gramaticales: \n");
		for(String s : producciones){
			System.out.println(s);
		}
	}
	
	public void finalAnalisis(){
		System.out.println(
		"-------------------------------------------------------------------------------------------------------------------------------------------------");
		System.out.println("Analisis Sintactico completado\n\n"+
							"AST resultado del analisis.");
		System.out.println(arbol.toString()+"\n");
		
		imprimirProducciones();
		
		System.out.println(
		"-------------------------------------------------------------------------------------------------------------------------------------------------");
		System.out.println("Tabla de simbolos\n");
		System.out.println(ts.toString());
		if(!errores.isEmpty())
			mostrarErrores();
			
	}
	
	public String fallo(int linea, int columna) {
		return Compilador.mostrarFallo(path, linea, columna);
	}
	

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Parser$actions {


	private void nuevoIDE(String ide, int fila, int columna){
		boolean yadefinida = false;
		int indiceyaesta = -1;
		for(Simbolo s : sinTipo){
			indiceyaesta++;
			if(s.nombre.equals(ide)){
				yadefinida = true;
				break;
			}
				
		}
		if(!yadefinida){
			if(!parser.ts.esta(ide)){
				Simbolo i = new Simbolo(ide, fila, columna);
				if(!i.tipo.equals("reservada")){
					sinTipo.add(i);
				}
				else
					parser.report_error("(SEMaNTICO) "+ ide+" definido en la linea "+fila+", caracter "+columna+" es una palabra reservada.\n"+parser.fallo(fila,columna), null);
			}else{
				Simbolo s = parser.ts.getSimbolo(ide);
				if(s.tipo.equals("reservada")){
					parser.report_error("(SEMaNTICO) "+ ide+" definido en la linea "+fila+", caracter "+columna+" es una palabra reservada.\n"+parser.fallo(fila,columna), null);
				}else
					parser.report_error("(SEMaNTICO) El ide "+ide+" declarado en la linea "+fila+", caracter "+columna+" ya fue declarado en "+s.filaYColumna()+"\n"+parser.fallo(fila,columna), null);
			}
		}else{
			Simbolo s = sinTipo.get(indiceyaesta);
			parser.report_error("(SEMaNTICO) El ide "+ide+" declarado en "+s.filaYColumna()+" ya fue declarado en la linea "+fila+", caracter "+columna+"\n"+parser.fallo(fila,columna), null);
			
		}
		
	}
	
	
	
	String tipo;
	
	ArrayList<Simbolo> sinTipo = new ArrayList<Simbolo>();
	
	private void ponerTipo(String tipo){
		if(tipo == null)
			tipo = "*ERROR*";
		for(Simbolo s : sinTipo){
			s.tipo = tipo;
			if(tipo.equalsIgnoreCase("integer"))
				s.valor = "0";
			else
				s.valor = "false";
			
			parser.ts.insertar(s);
		}
		sinTipo.clear();
	}
	
	private void newProduccion(String p){
		int c = parser.producciones.size();
		c++;
		parser.producciones.add("Regla #"+c+" --> "+p);
	}
	

  private final Parser parser;

  /** Constructor */
  CUP$Parser$actions(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Parser$do_action(
    int                        CUP$Parser$act_num,
    java_cup.runtime.lr_parser CUP$Parser$parser,
    java.util.Stack            CUP$Parser$stack,
    int                        CUP$Parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Parser$result;

      /* select the action based on the action number */
      switch (CUP$Parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // IDEOENTERO ::= tk_numeroentero 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer e = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("IDEOENTERO ::= tk_numeroentero");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo(e.toString());
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IDEOENTERO",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // IDEOENTERO ::= tk_identificador 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("IDEOENTERO ::= tk_identificador");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo(i.nombre);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i.nombre,ileft,iright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("IDEOENTERO",18, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // OPERADORMATES ::= tk_division 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("OPERADORMATES ::= tk_division");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("entre");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERADORMATES",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // OPERADORMATES ::= tk_multiplicacion 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("OPERADORMATES ::= tk_multiplicacion");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("por");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERADORMATES",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // OPERADORMATES ::= tk_resta 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("OPERADORMATES ::= tk_resta");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("menos");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERADORMATES",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // OPERADORMATES ::= tk_suma 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("OPERADORMATES ::= tk_suma");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("mas");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("OPERADORMATES",19, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // LISTADEASIGNACIONES ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("**LISTA_ASIGNACIONES_ERRONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTADEASIGNACIONES ::= error");
			parser.report_error("(SINTaCTICO) Asignacion mal definida en la linea: "+eleft+", caracter: "+eright+"\n"+parser.fallo(eleft,eright), null);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTADEASIGNACIONES",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // LISTADEASIGNACIONES ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTADEASIGNACIONES ::= .");

			/**** (6). Diseno del AST				   ****/
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTADEASIGNACIONES",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // LISTADEASIGNACIONES ::= OPERADORMATES IDEOENTERO LISTADEASIGNACIONES 
            {
              Nodo RESULT =null;
		int opleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int opright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nodo op = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo i = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int laleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int laright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo la = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTADEASIGNACIONES ::= OPERADORMATES IDEOENTERO LISTADEASIGNACIONES");
			
			/**** (6). Diseno del AST				   ****/
			Nodo oper = new Nodo(op.valor);
			String ioe = "";
			if(Compilador.isNumeric(i.valor)){
				ioe = "num("+i.valor+")";				
			}else{
				ioe = "ide("+i.valor+")";
			}
			Nodo ie = new Nodo(ioe);
			Arbol.unirHermanos(oper,ie);
			if(la == null){
				RESULT = new Nodo(op.valor+","+ioe);
			}else{
				RESULT = new Nodo(op.valor+","+ioe+","+la.valor);
				Arbol.unirHermanos(ie, la);
			}
			Arbol.unirParientes(RESULT, oper);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Si IDEOENTERO es un identificador
			if(ioe.contains("ide")){
				//se saca la lista de identificadores de la actual lista de asignaciones.
				ArrayList<String> ides = Compilador.sacaIDEs(RESULT.valor);
				//Si no esta vacia
				if(!ides.isEmpty()){
					//Se coge el primer ide. (puesto que si existieran mas, las comprobarian
					//las diferentes sucesiones de esta produccion.
					String ide = ides.get(0);
					//Y se comprueba que fuera declarada.
					if(!parser.ts.esta(ide)){
						parser.report_error("(SEMaNTICO) "+ide +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
					}
				}
			}
			//Se comprueba que no se este dividiendo entre cero.
			boolean divisioncero = false;
			//Si la operacion es entre.
			if(op.valor.equals("entre")){
				//Y el valor de IDEOENTERO es el numero 0, sera un error.
				if(ioe.equals("num(0)")){
					divisioncero = true;
				}else{
					//Sino, se comprueba si el ide esta inicializado siempre que este en la tabla de simbolos
					if(parser.ts.esta(i.valor)){
						//y ademas sea de tipo entero.
						Simbolo s = parser.ts.getSimbolo(i.valor);
						if(!s.inicializada && s.tipo.equals("integer")){
							divisioncero = true;
						}
					}
					//La comprobacion de si no esta declarada ya fue lineas atras.
				}
			}
			//Si se ha comprobado que habra una division entre cero se muestra el error.
			if(divisioncero){
				parser.report_error("(SEMaNTICO) Se esta intentando dividir entre 0. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTADEASIGNACIONES",22, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // AVERQUEASIGNAMOS ::= tk_parenizq LISTAEXPRESIONES tk_parender 
            {
              Nodo RESULT =null;
		int leleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo le = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("AVERQUEASIGNAMOS ::= tk_parenizq LISTAEXPRESIONES tk_parender");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo(le.valor);
			Arbol.unirParientes(RESULT, le);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AVERQUEASIGNAMOS",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // AVERQUEASIGNAMOS ::= tk_not tk_parenizq LISTAEXPRESIONES tk_parender 
            {
              Nodo RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo le = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("AVERQUEASIGNAMOS ::= tk_not tk_parenizq LISTAEXPRESIONES tk_parender");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("not("+le.valor+")");
			Nodo not = new Nodo("not");
			Arbol.unirHermanos(not,le);
			Arbol.unirParientes(RESULT, not);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("not",nleft,nright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AVERQUEASIGNAMOS",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // AVERQUEASIGNAMOS ::= IDEOENTERO LISTADEASIGNACIONES 
            {
              Nodo RESULT =null;
		int ieleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ieright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo ie = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int laleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int laright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo la = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("AVERQUEASIGNAMOS ::= IDEOENTERO LISTADEASIGNACIONES");
			
			/**** (6). Diseno del AST				   ****/
			if(la == null){
				RESULT = new Nodo(ie);
			}else{
				String ioe = "";
				//Comprobamos que lo que ha devuelto IDEOENTERO sea un numero o un identificador.
				if(Compilador.isNumeric(ie.valor)){
					ioe = "num("+ie.valor+")";				
				}else{
					ioe = "ide("+ie.valor+")";
				}
				RESULT = new Nodo("exp("+ioe+","+la.valor+")");
				Arbol.unirHermanos(ie, la);
			}
			Arbol.unirParientes(RESULT, ie);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AVERQUEASIGNAMOS",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // AVERQUEASIGNAMOS ::= tk_false 
            {
              Nodo RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object f = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("AVERQUEASIGNAMOS ::= tk_false");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("false");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("false",fleft,fright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AVERQUEASIGNAMOS",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // AVERQUEASIGNAMOS ::= tk_true 
            {
              Nodo RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("AVERQUEASIGNAMOS ::= tk_true");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("true");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("true",tleft,tright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("AVERQUEASIGNAMOS",11, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // COMPARACION ::= tk_identificador tk_comparacion tk_identificador 
            {
              Nodo RESULT =null;
		int i1left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int i1right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Simbolo i1 = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int i2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int i2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbolo i2 = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("COMPARACION ::= tk_identificador tk_comparacion tk_identificador");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("exp("+c+",ide("+i1.nombre+"),ide("+i2.nombre+"))");
			Nodo ide1 = new Nodo(i1.nombre);
			Nodo ide2 = new Nodo(i2.nombre);
			Nodo com = new Nodo(c);
			Arbol.unirHermanos(ide1, com);
			Arbol.unirHermanos(com, ide2);
			Arbol.unirParientes(RESULT, ide1);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i1.nombre,i1left,i1right);
			parser.ts.usada(i2.nombre,i2left,i2right);
			
			/**** (4). Diseno del analizdor semantico  ****/
			boolean estan = true;
			if(!parser.ts.esta(i1.nombre)){
				//Si no esta declarada la variable se avisa.
				parser.report_error("(SEMaNTICO) "+i1.nombre +" no fue declarada. Linea: "+i1left+", caracter: "+i1right+"\n"+parser.fallo(i1left,i1right), null);
				estan = false;
			}
			if(!parser.ts.esta(i2.nombre)){
				//Si no esta declarada la variable se avisa.
				parser.report_error("(SEMaNTICO) "+i2.nombre +" no fue declarada. Linea: "+i2left+", caracter: "+i2right+"\n"+parser.fallo(i2left,i2right), null);
				estan = false;
			}
			if(estan){
				Simbolo si1 = parser.ts.getSimbolo(i1.nombre);
				Simbolo si2 = parser.ts.getSimbolo(i2.nombre);
				if(!si1.tipo.equals(si2.tipo)){
					parser.report_error("(SEMaNTICO) "+si1.nombre +" y "+si2.nombre+" no son del mismo tipo. Linea: "+i1left+", caracter: "+i1right+"\n"+parser.fallo(i1left,i1right), null);
				}
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COMPARACION",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // COMPARACION ::= tk_true 
            {
              Nodo RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("COMPARACION ::= tk_true");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("true");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("true",tleft,tright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COMPARACION",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // COMPARACION ::= tk_identificador 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("COMPARACION ::= tk_identificador");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("ide("+i.nombre+")");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			if(parser.ts.esta(i.nombre)){
				Simbolo si = parser.ts.getSimbolo(i.nombre);
				//La comparacion solo puede ser con un identificador booleano para que solo de true o false.
				if(!si.tipo.equals("boolean")){
					parser.report_error("(SEMaNTICO) "+si.nombre +" no es de tipo booleano. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
				}
			}else{
				//Si la variable no fue declarada
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COMPARACION",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // COMPARACION ::= tk_numeroentero tk_comparacion tk_identificador 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Integer e = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("COMPARACION ::= tk_numeroentero tk_comparacion tk_identificador");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("exp("+c+",num("+e.toString()+"),ide("+i.nombre+")");
			Nodo ide = new Nodo(i.nombre);
			Nodo com = new Nodo(c);
			Nodo num = new Nodo("num("+e.toString()+")");
			Arbol.unirHermanos(num, com);
			Arbol.unirHermanos(com, ide);
			Arbol.unirParientes(RESULT, num);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			if(parser.ts.esta(i.nombre)){
				//De nuevo, la comparacion debe ser entre dos enteros.
				Simbolo si = parser.ts.getSimbolo(i.nombre);
				if(!si.tipo.equals("integer")){
					parser.report_error("(SEMaNTICO) "+si.nombre +" no es de tipo entero. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
				}
			}else{
				//Si no fue declarada se advierte.
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COMPARACION",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // COMPARACION ::= tk_identificador tk_comparacion tk_numeroentero 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		String c = (String)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Integer e = (Integer)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("COMPARACION ::= tk_identificador tk_comparacion tk_numeroentero");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("exp("+c+",ide("+i.nombre+"),num("+e.toString()+"))");
			Nodo ide = new Nodo(i.nombre);
			Nodo com = new Nodo(c);
			Nodo num = new Nodo("num"+e.toString()+")");
			Arbol.unirHermanos(ide, com);
			Arbol.unirHermanos(com, num);
			Arbol.unirParientes(RESULT, ide);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			if(parser.ts.esta(i.nombre)){
				//Se comprueba que la comparacion de un entero sea con un identificador de tipo entero.
				Simbolo si = parser.ts.getSimbolo(i.nombre);
				if(!si.tipo.equals("integer")){
					parser.report_error("(SEMaNTICO) "+si.nombre +" no es de tipo entero. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
				}
			}else{
				//Si no esta declarada la variable se avisa.
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("COMPARACION",21, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // EXPRESIONBOOLEANA ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("**EXPRESION_BOOLEANA_ERRORONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EXPRESIONBOOLEANA ::= error");
			parser.report_error("(SINTaCTICO) La expresion booleana de la linea "+eleft+", columna "+eright+" no esta bien definida"+"\n"+parser.fallo(eleft,eright), e);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPRESIONBOOLEANA",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // EXPRESIONBOOLEANA ::= tk_not tk_parenizq LISTAEXPRESIONES tk_parender 
            {
              Nodo RESULT =null;
		int nleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int nright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Object n = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo l = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EXPRESIONBOOLEANA ::= tk_not tk_parenizq LISTAEXPRESIONES tk_parender");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("not("+l.valor+")");
			Nodo not = new Nodo("not");
			Arbol.unirHermanos(not, l);
			Arbol.unirParientes(RESULT, not);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("not",nleft,nright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPRESIONBOOLEANA",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // EXPRESIONBOOLEANA ::= COMPARACION 
            {
              Nodo RESULT =null;
		int cleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo c = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EXPRESIONBOOLEANA ::= COMPARACION");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo(c.valor);
			Arbol.unirParientes(RESULT, c);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPRESIONBOOLEANA",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // EXPRESIONBOOLEANA ::= tk_parenizq LISTAEXPRESIONES tk_parender 
            {
              Nodo RESULT =null;
		int lleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int lright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo l = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EXPRESIONBOOLEANA ::= tk_parenizq LISTAEXPRESIONES tk_parender");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo(l.valor);
			Arbol.unirParientes(RESULT, l);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EXPRESIONBOOLEANA",20, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // SIGUEEXPRESION ::= tk_or 
            {
              Nodo RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object o = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("SIGUEEXPRESION ::= tk_or");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("or");

			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("or",oleft,oright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGUEEXPRESION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // SIGUEEXPRESION ::= tk_and 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object a = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("SIGUEEXPRESION ::= tk_and");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("and");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("and",aleft,aright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("SIGUEEXPRESION",13, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // EAA ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EAA ::= .");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EAA",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // EAA ::= SIGUEEXPRESION EXPRESIONBOOLEANA EAA 
            {
              Nodo RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Nodo se = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ebleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ebright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo eb = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo e = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("EAA ::= SIGUEEXPRESION EXPRESIONBOOLEANA EAA");
			
			/**** (6). Diseno del AST				   ****/
			Arbol.unirHermanos(se, eb);
			if(e == null)
				RESULT = new Nodo(" "+se.valor+" "+eb.valor);
			else{
				RESULT = new Nodo(" "+se.valor+" "+eb.valor+e.valor);
				Arbol.unirHermanos(eb, e);
			}
			Arbol.unirHermanos(RESULT, se);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("EAA",14, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // LISTAEXPRESIONES ::= EXPRESIONBOOLEANA EAA 
            {
              Nodo RESULT =null;
		int ebleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int ebright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo eb = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo e = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTAEXPRESIONES ::= EXPRESIONBOOLEANA EAA");
			
			/**** (6). Diseno del AST				   ****/
			if(e == null){
				RESULT = new Nodo(eb.valor);
			}else{
				RESULT = new Nodo(eb.valor +","+ e.valor);
				Arbol.unirHermanos(eb,e);
			}
			Arbol.unirParientes(RESULT,eb);			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTAEXPRESIONES",12, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // DEFINICIONELSE ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONELSE ::= .");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // DEFINICIONELSE ::= tk_else BLOQUEDESENTENCIAS 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONELSE ::= tk_else BLOQUEDESENTENCIAS");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo(bds.valor);
			Arbol.unirParientes(RESULT, bds);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("else",eleft,eright);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONELSE",16, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // DEFINICIONIF ::= tk_if LISTAEXPRESIONES tk_then BLOQUEDESENTENCIAS DEFINICIONELSE tk_end tk_if tk_puntoycoma 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-7)).value;
		int leleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int leright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Nodo le = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int deleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int deright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nodo de = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int i2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int i2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object i2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONIF ::= tk_if LISTAEXPRESIONES tk_then BLOQUEDESENTENCIAS DEFINICIONELSE tk_end tk_if tk_puntoycoma");

			/**** (6). Diseno del AST				   ****/	
			if(de == null){
				RESULT = new Nodo("if("+le.valor+",["+bds.valor+"])");
			}else{
				RESULT = new Nodo("if("+le.valor+",["+bds.valor+"],else["+de.valor+"])");
				Arbol.unirHermanos(bds, de);
			}
			Arbol.unirHermanos(le, bds);
			Arbol.unirParientes(RESULT, le);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("if",ileft,iright);
			parser.ts.usada("if",i2left,i2right);
			parser.ts.usada("end",eleft,eright);
			parser.ts.usada("then",tleft,tright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONIF",15, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-7)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // DEFINICIONSENTENCIA ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("**SENTENCIA_ERRONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= error");
			parser.report_error("(SINTaCTICO) Problema en la sentencia de la linea "+eleft+", columna "+eright+"\n"+parser.fallo(eleft,eright), e);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // DEFINICIONSENTENCIA ::= tk_identificador tk_asignacion AVERQUEASIGNAMOS tk_puntoycoma 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo e = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= tk_identificador tk_asignacion AVERQUEASIGNAMOS tk_puntoycoma");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("asign("+i.nombre+","+e.valor+")");
			Nodo ide = new Nodo(i.nombre);
			Nodo as = new Nodo("asign");
			Arbol.unirHermanos(ide,as);
			Arbol.unirHermanos(as, e);
			Arbol.unirParientes(RESULT, ide);
			
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Comprobaciones de que lo que se encuentra a la izquierda coincide en tipo a lo de la derecha.
			String asign = e.valor;
			if(parser.ts.esta(i.nombre)){
				//Se indica que la variable ha sido inicializada.
				Simbolo si = parser.ts.getSimbolo(i.nombre);
				if(!si.inicializada){
					si.inicializada = true;
				}
				//Obtiene los identificadores de la lista de asignaciones.
				ArrayList<String> ides = Compilador.sacaIDEs(asign);
				//Y comprobamos sus tipos.
				String tipoIDEs = Compilador.tipoIDEs(parser.ts, ides);
				//Si la parte de la izquierda es de tipo entero.
				if(si.tipo.equals("integer")){
					//La parte de la derecha no puede ser de ambos tipos o solo boolean, en ese caso se muestra un mensaje de error.
					if(tipoIDEs.equals("ambos") || tipoIDEs.equals("boolean")
						|| asign.contains("true") || asign.contains("false")
						|| asign.contains("menor") || asign.contains("mayor")
						|| asign.contains("igual") || asign.contains("mayorigual")
						|| asign.contains("menorigual")){
						parser.report_error("(SEMaNTICO) "+i.nombre +" es de tipo "+si.tipo+", mientras que se le esta asignando un valor de tipo boolean"+
						". Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
					}
				}else{
					//Si no es entero, solo puede ser booleano y debe coincidir con este.
					//En cuanto no se encuentre ninguna de estas cadenas ni sea de tipo booleano,
					//entonces no coinciden los tipos.
					if(!asign.contains("true") && !asign.contains("false") && !asign.contains("not") && !tipoIDEs.equals("boolean") &&
						!asign.contains("menor") &&	!asign.contains("menorigual") &&!asign.contains("igual") &&!asign.contains("mayorigual") &&!asign.contains("mayor")){
							parser.report_error("(SEMaNTICO) "+i.nombre +" es de tipo "+si.tipo+", mientras que se le esta asignando un valor de tipo entero"+
							". Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
					}
				}
			}else{
				//Si la variable no esta declarada se avisa.
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // DEFINICIONSENTENCIA ::= tk_while LISTAEXPRESIONES tk_do BLOQUEDESENTENCIAS tk_end tk_while tk_puntoycoma 
            {
              Nodo RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-6)).value;
		int lsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).left;
		int lsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-5)).right;
		Nodo ls = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5)).value;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object d = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int w2left = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int w2right = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object w2 = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= tk_while LISTAEXPRESIONES tk_do BLOQUEDESENTENCIAS tk_end tk_while tk_puntoycoma");
			
			/**** (6). Diseno del AST				   ****/	
			if(bds == null){
				bds = new Nodo("no_sentences");
			}
			RESULT = new Nodo("while("+ls.valor+",["+bds.valor+"], skip)");
			Arbol.unirHermanos(ls, bds);
			Arbol.unirParientes(RESULT, ls);
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("while",wleft,wright);
			parser.ts.usada("do",dleft,dright);
			parser.ts.usada("while",w2left,w2right);
			parser.ts.usada("end",eleft,eright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			ArrayList<String> vals = Compilador.sacaIDEs(ls.valor);
			//Se obtienen las variables que se estan utilizando en el bloque de sentencias y se comprueba que tenga fin.
			if(!Compilador.finWhile(vals,bds.valor)){
				parser.report_error("(SEMaNTICO) Es posible que el while definido en la linea "+wleft+", caracter: "+wright+
				" sea indefinido.\n"+parser.fallo(wleft,wright), null);
			}
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-6)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // DEFINICIONSENTENCIA ::= DEFINICIONIF 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo i = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= DEFINICIONIF");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = i;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // DEFINICIONSENTENCIA ::= tk_write tk_identificador tk_puntoycoma 
            {
              Nodo RESULT =null;
		int wleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int wright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object w = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= tk_write tk_identificador tk_puntoycoma");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("write(ide("+i.nombre+"))");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("write",wleft,wright);
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Comprueba que la variable esta definida y que haya sido inicializada para poder escribir.
			if(parser.ts.esta(i.nombre)){
				i = parser.ts.getSimbolo(i.nombre);
				if(!i.inicializada){
					parser.report_error("(SEMaNTICO) "+i.nombre +" no se puede escribir si no ha sido antes inicializada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
				}
			}else{
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // DEFINICIONSENTENCIA ::= tk_read tk_identificador tk_puntoycoma 
            {
              Nodo RESULT =null;
		int rleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int rright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object r = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= tk_read tk_identificador tk_puntoycoma");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("read(ide("+i.nombre+"))");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("read",rleft,rright);
			parser.ts.usada(i.nombre,ileft,iright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Comprueba que la variable ya esta definida y que es un tipo entero para poder ser leida.
			if(parser.ts.esta(i.nombre)){
				i = parser.ts.getSimbolo(i.nombre);
				if(!i.tipo.equals("integer")){
					parser.report_error("(SEMaNTICO) "+i.nombre +" no es de tipo entero, no se puede leer. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
				}
			}else{
				parser.report_error("(SEMaNTICO) "+i.nombre +" no fue declarada. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
					
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // DEFINICIONSENTENCIA ::= tk_skip tk_puntoycoma 
            {
              Nodo RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object s = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONSENTENCIA ::= tk_skip tk_puntoycoma");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("skip");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("skip",sleft,sright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONSENTENCIA",10, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // BDSA ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("BDSA ::= .");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BDSA",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // BDSA ::= DEFINICIONSENTENCIA BDSA 
            {
              Nodo RESULT =null;
		int dsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int dsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo ds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("BDSA ::= DEFINICIONSENTENCIA BDSA");
			
			/**** (6). Diseno del AST				   ****/			
			if(bds == null){
				RESULT = ds;
			}else{
				RESULT = new Nodo(ds.valor +","+ bds.valor);
				Arbol.unirHermanos(ds,bds);
			}			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BDSA",8, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // BLOQUEDESENTENCIAS ::= BDSA 
            {
              Nodo RESULT =null;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("BLOQUEDESENTENCIAS ::= BDSA");
			
			/**** (6). Diseno del AST				   ****/
			if(bds == null)
				RESULT = new Nodo("no_sentences");
			else
				RESULT = bds;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOQUEDESENTENCIAS",9, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // DECLARACIONTIPO ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("**TIPO_ERRONEO**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DECLARACIONTIPO ::= error");
			parser.report_error("(SEMaNTICO) Imposible asignarle dicho tipo de dato. Solo se puede \"integer\" o \"boolean\". Linea: "+eleft+", caracter: "+eright+"\n"+parser.fallo(eleft,eright), null);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARACIONTIPO",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // DECLARACIONTIPO ::= tk_boolean 
            {
              Nodo RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DECLARACIONTIPO ::= tk_boolean");
			
			/**** (6). Diseno del AST				   ****/	
			RESULT = new Nodo("boolean");
			
			/**** (4). Diseno del analizdor semantico  ****/
			tipo = "boolean";
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("boolean",bleft,bright);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARACIONTIPO",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // DECLARACIONTIPO ::= tk_integer 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object i = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DECLARACIONTIPO ::= tk_integer");
			
			/**** (6). Diseno del AST				   ****/			
			RESULT = new Nodo("integer");
			
			/**** (4). Diseno del analizdor semantico  ****/
			tipo = "integer";
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("integer",ileft,iright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DECLARACIONTIPO",6, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // DEFINICIONPROGRAMA ::= tk_begin BLOQUEDESENTENCIAS tk_end 
            {
              Nodo RESULT =null;
		int bleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int bright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object b = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int bdsleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bdsright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo bds = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONPROGRAMA ::= tk_begin BLOQUEDESENTENCIAS tk_end");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo(bds.valor);
			Arbol.unirParientes(RESULT, bds);
			
			/**** (5). Diseno de la tabla de simbolos ****/		
			parser.ts.usada("begin",bleft,bright);
			parser.ts.usada("end",eleft,eright);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONPROGRAMA",1, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // LVA ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("**LISTA_VARIABLES_ERRONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LVA ::= error");
			parser.report_error("(SINTaCTICO) Es necesario una coma para delimitar los identificadores de la linea "+eleft+", columna "+eright+"\n"+parser.fallo(eleft,eright), e);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LVA",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // LVA ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LVA ::= .");
			
			/**** (6). Diseno del AST				   ****/			
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LVA",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // LVA ::= tk_coma tk_identificador LVA 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lvauxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lvauxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo lvaux = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			if(lvaux == null){
				RESULT = new Nodo(i.nombre);
			}else{
				RESULT = new Nodo(i.nombre +","+lvaux.valor);
				Arbol.unirHermanos(RESULT, lvaux);
			}
			
			/**** (4). Diseno del analizdor semantico  ****/				
			nuevoIDE(i.nombre, ileft, iright);
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LVA ::= tk_coma tk_identificador LVA");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LVA",7, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LISTAVARIABLES ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("**LISTA_VARIABLES_ERRONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTAVARIABLES ::= .");
			parser.report_error("(SINTaCTICO) Se debe finalizar la sentencia con un punto y coma tras el token en la linea "+eleft+", columna "+eright+"\n"+parser.fallo(eleft,eright), e);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTAVARIABLES",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // LISTAVARIABLES ::= tk_identificador LVA 
            {
              Nodo RESULT =null;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int lvauxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int lvauxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo lvaux = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			if(lvaux == null){
				RESULT = new Nodo(i.nombre);
			}else{
				RESULT = new Nodo(i.nombre +","+lvaux.valor);
				Arbol.unirHermanos(RESULT, lvaux);
			}
			
			/**** (4). Diseno del analizdor semantico  ****/			
			nuevoIDE(i.nombre, ileft, iright);
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("LISTAVARIABLES ::= tk_identificador LVA");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("LISTAVARIABLES",5, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // DEFINICIONVARIABLE ::= error 
            {
              Nodo RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Object e = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("**DEFINICION_VARIABLE_ERRONEA**");
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONVARIABLE ::= error");
			parser.report_error("(SINTaCTICO) Problema en la asignacion de identificadores en la linea "+eleft+", caracter "+eright+"\n"+parser.fallo(eleft,eright), e);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONVARIABLE",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // DEFINICIONVARIABLE ::= tk_var LISTAVARIABLES tk_dospuntos DECLARACIONTIPO tk_puntoycoma 
            {
              Nodo RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object v = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int lvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int lvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Nodo lv = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int dtleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int dtright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo dt = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DEFINICIONVARIABLE ::= tk_var LISTAVARIABLES tk_dospuntos DECLARACIONTIPO tk_puntoycoma");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("var",vleft,vright);
			
			/**** (6). Diseno del AST				   ****/
			//Si existen errores y no se ha podido generar el nodo, lo generamos con un mensaje de error.
			if(lv == null){
				lv = new Nodo("**ERROR_LISTA_VARIABLES**");
			}
			if(dt == null){
				dt = new Nodo("**ERROR_TIPO_VARIABLE**");
			}
			//El nodo resultante, el padre de la declaracion, se une con sus hijos, las variables y el tipo.
			RESULT = new Nodo(dt.valor+",["+lv.valor+"]");
			Arbol.unirHermanos(dt,lv);
			Arbol.unirParientes(RESULT, dt);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Una vez conocido el tipo de la lista de varibles definidas, se anade a la tabla de simbolos con su tipo.
			ponerTipo(tipo);
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DEFINICIONVARIABLE",4, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // DVA ::= 
            {
              Nodo RESULT =null;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DVA ::= .");
			
			/**** (6). Diseno del AST				   ****/
			RESULT = null;
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DVA",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // DVA ::= DEFINICIONVARIABLE DVA 
            {
              Nodo RESULT =null;
		int dvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int dvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo dv = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int dvauxleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dvauxright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo dvaux = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("DVA ::= DEFINICIONVARIABLE DVA");
			
			/**** (6). Diseno del AST				   ****/
			if(dvaux == null)
				//Si solo hay una declaracion de variable se muestra.
				RESULT = new Nodo("decl("+dv.valor+")");
			else{
				//Si existe mas de una declaracion se unen como hermanos, puesto que estan en el mismo nivel.
				RESULT = new Nodo("decl("+dv.valor +"),"+ dvaux.valor);
				Arbol.unirHermanos(dv, dvaux);
			}
			//Finalmente, se junta el resultado, el padre, con su hijo, la definicion de variable.
			Arbol.unirParientes(RESULT, dv);
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("DVA",3, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // BLOQUEDEFINICIONVARIABLES ::= DVA 
            {
              Nodo RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo d = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
			
			/**** (6). Diseno del AST				   ****/
			if(d == null)
				RESULT = new Nodo("no_decls");
			else
				RESULT = d;
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("BLOQUEDEFINICIONVARIABLES ::= DVA");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("BLOQUEDEFINICIONVARIABLES",2, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // PROGRAM ::= tk_program tk_identificador tk_is BLOQUEDEFINICIONVARIABLES DEFINICIONPROGRAMA 
            {
              Nodo RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)).right;
		Object p = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-4)).value;
		int ileft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).left;
		int iright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-3)).right;
		Simbolo i = (Simbolo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3)).value;
		int isleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).left;
		int isright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-2)).right;
		Object is = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2)).value;
		int bdvleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int bdvright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Nodo bdv = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		int dpleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int dpright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo dp = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
		
			/**** (6). Diseno del AST				   ****/
			RESULT = new Nodo("program["+i.nombre+"](["+bdv.valor+"],["+dp.valor+"])");	
			Arbol.unirParientes(RESULT, bdv);
			Arbol.unirHermanos(bdv,dp);
			
			/**** (3). Diseno del analizdor sintactico ****/
			newProduccion("PROGRAM ::= tk_program tk_identificador tk_is BLOQUEDEFINICIONVARIABLES DEFINICIONPROGRAMA");
			
			/**** (5). Diseno de la tabla de simbolos ****/
			parser.ts.usada("program",pleft,pright);
			parser.ts.usada("is",isleft,isright);
			
			/**** (4). Diseno del analizdor semantico  ****/
			//Identificadores no reservados, todos los demas definidos a lo largo del programa.
			ArrayList<Simbolo> ides = parser.ts.getIdentificadores();
			//Por cada simbolo de la lista anterior
			for(Simbolo s : ides){
				//Si la variable definida no ha sido usada a lo largo del problema se muestra un mensaje
				//advirtiendo de que no esta siendo usada.
				if(s.usadaEn.isEmpty())
					parser.report_error("(SEMaNTICO) La variable "+s.nombre+" ha sido declarada pero no usada.\n"+parser.fallo(s.fila,s.columna), null);
			}
			//Si en la tabla de simbolos no esta el nombre del programa
			if(!parser.ts.esta(i.nombre)){
				//Lo anadimos a la tabla de simbolos con el tipo "pseudo".
				parser.ts.insertar(new Simbolo(i.nombre, ileft, iright, "pseudo"));
			}else{
				//Si ya estaba antes, se reporta un mensaje de error al usuario.
				parser.report_error("(SEMaNTICO) El nombre del programa ("+i.nombre+") coincide con el de una variable. Linea: "+ileft+", caracter: "+iright+"\n"+parser.fallo(ileft,iright), null);
			}
			
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("PROGRAM",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-4)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // INICIO ::= PROGRAM 
            {
              Object RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()).right;
		Nodo p = (Nodo)((java_cup.runtime.Symbol) CUP$Parser$stack.peek()).value;
					
			/**** (6). Diseno del AST				   ****/
			parser.arbol.raiz = p;
			parser.finalAnalisis();
			
			/**** (3). Diseno del analizdor sintactico ****/
			parser.done_parsing();
			newProduccion("INICIO ::= PROGRAM");
		
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("INICIO",17, ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          return CUP$Parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INICIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1)).value;
		RESULT = start_val;
              CUP$Parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Parser$stack.elementAt(CUP$Parser$top-1)), ((java_cup.runtime.Symbol)CUP$Parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Parser$parser.done_parsing();
          return CUP$Parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

